{"remainingRequest":"/mnt/c/Studium/Angewandte_Informatik/Master/2te_Semester/Seminar/datamining_frequent_itemset/datamining_frequent_itemset/website/node_modules/vue-loader/lib/index.js??vue-loader-options!/mnt/c/Studium/Angewandte_Informatik/Master/2te_Semester/Seminar/datamining_frequent_itemset/datamining_frequent_itemset/website/src/components/diagrams/MultiLineChart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/mnt/c/Studium/Angewandte_Informatik/Master/2te_Semester/Seminar/datamining_frequent_itemset/datamining_frequent_itemset/website/src/components/diagrams/MultiLineChart.vue","mtime":1588499118168},{"path":"/mnt/c/Studium/Angewandte_Informatik/Master/2te_Semester/Seminar/datamining_frequent_itemset/datamining_frequent_itemset/website/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/mnt/c/Studium/Angewandte_Informatik/Master/2te_Semester/Seminar/datamining_frequent_itemset/datamining_frequent_itemset/website/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/mnt/c/Studium/Angewandte_Informatik/Master/2te_Semester/Seminar/datamining_frequent_itemset/datamining_frequent_itemset/website/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/mnt/c/Studium/Angewandte_Informatik/Master/2te_Semester/Seminar/datamining_frequent_itemset/datamining_frequent_itemset/website/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGQzIGZyb20gImQzIjsKaW1wb3J0IHsgc2NhbGVMaW5lYXIsIHNjYWxlQmFuZCB9IGZyb20gImQzLXNjYWxlIjsKaW1wb3J0IHsgbWF4LCBtaW4gfSBmcm9tICJkMy1hcnJheSI7CmltcG9ydCB7IHNlbGVjdEFsbCB9IGZyb20gImQzLXNlbGVjdGlvbiI7CgpleHBvcnQgZGVmYXVsdCB7CiAgICBuYW1lOiAiVGVzdC1DaGFydCIsCiAgICBwcm9wczogewogICAgICAgIGRhdGE6IE9iamVjdAogICAgfSwKICAgIGRhdGEoKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgdGVzdGRhdGE6IHsKICAgICAgICAgICAgICAgIFBMQTogewogICAgICAgICAgICAgICAgICAgIEE6IDEsCiAgICAgICAgICAgICAgICAgICAgQjogMgogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgIFBCUzogewogICAgICAgICAgICAgICAgICAgIEE6IDEsCiAgICAgICAgICAgICAgICAgICAgQjogNAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBpZDogOTAwMCwKICAgICAgICAgICAgaGVpZ2h0OiA2MDAsCiAgICAgICAgICAgIGhlaWdodFNWRzogMCwKICAgICAgICAgICAgd2lkdGhTVkc6IDAsCiAgICAgICAgICAgIHdpZHRoOiA2MDAsCiAgICAgICAgICAgIG1hcmdpbjogeyB0b3A6IDMwLCByaWdodDogMzAsIGJvdHRvbTogMzAsIGxlZnQ6IDcwIH0sCiAgICAgICAgICAgIG1hcmdpbl90b3A6IDIwLAogICAgICAgICAgICBtYXJnaW5fbGVmdDogNTAsCiAgICAgICAgICAgIGtleXNYMDogW10sCiAgICAgICAgICAgIGtleXNYMTogW10sCiAgICAgICAgICAgIHZhbHVlczogW10sCiAgICAgICAgICAgIG1heFgxOiAwLAogICAgICAgICAgICB4MDogT2JqZWN0LAogICAgICAgICAgICB4MTogT2JqZWN0LAogICAgICAgICAgICB5OiBPYmplY3QsCiAgICAgICAgICAgIGNvbG9yOiBPYmplY3QsCiAgICAgICAgICAgIHN2ZzogT2JqZWN0LAogICAgICAgICAgICBjb250YWluZXI6IE9iamVjdCwKICAgICAgICAgICAgeEF4aXM6IE9iamVjdCwKICAgICAgICAgICAgeUF4aXM6IE9iamVjdCwKICAgICAgICAgICAgZ3JvdXBzOiBPYmplY3QsCiAgICAgICAgICAgIGxpbmVzOiBPYmplY3QsCiAgICAgICAgICAgIHBvaW50czogT2JqZWN0CiAgICAgICAgfTsKICAgIH0sCiAgICBjb21wdXRlZDoge30sCiAgICBtb3VudGVkKCkgewogICAgICAgIHRoaXMuaW5pdCgpOwogICAgICAgIHRoaXMuZHJhdygpOwogICAgfSwKICAgIGNyZWF0ZWQoKSB7CiAgICB9LAogICAgbWV0aG9kczogewogICAgICAgIGluaXQoKSB7CiAgICAgICAgICAgIHRoaXMuc3ZnID0gZDMuc2VsZWN0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpKTsKICAgICAgICAgICAgdGhpcy5zdmcKICAgICAgICAgICAgICAgIC5hdHRyKCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwgInhNaW5ZTWluIG1lZXQiKQogICAgICAgICAgICAgICAgLmF0dHIoInZpZXdCb3giLCAiMCAwICIgKyB0aGlzLndpZHRoICsgIiAiICsgdGhpcy5oZWlnaHQpOwoKICAgICAgICAgICAgdGhpcy53aWR0aFNWRyA9IHRoaXMud2lkdGggLSB0aGlzLm1hcmdpbi5sZWZ0IC0gdGhpcy5tYXJnaW4ucmlnaHQ7CiAgICAgICAgICAgIHRoaXMuaGVpZ2h0U1ZHID0gdGhpcy5oZWlnaHQgLSB0aGlzLm1hcmdpbi50b3AgLSB0aGlzLm1hcmdpbi5ib3R0b207CgogICAgICAgICAgICB0aGlzLmtleXNYMCA9IE9iamVjdC5rZXlzKHRoaXMudGVzdGRhdGEpOwogICAgICAgICAgICB0aGlzLnZhbHVlcyA9IE9iamVjdC52YWx1ZXModGhpcy50ZXN0ZGF0YSk7CiAgICAgICAgICAgIHRoaXMua2V5c1gxID0gT2JqZWN0LmtleXModGhpcy52YWx1ZXNbMF0pOwoKICAgICAgICAgICAgdGhpcy5jb2xvciA9IGQzLnNjYWxlT3JkaW5hbChkMy5zY2hlbWVDYXRlZ29yeTEwKTsKCiAgICAgICAgICAgIHRoaXMubWF4WDEgPSB0aGlzLmZpbmRNYXgodGhpcy52YWx1ZXMsIHRoaXMua2V5c1gxKTsKCiAgICAgICAgICAgIHRoaXMueDAgPSBkMwogICAgICAgICAgICAgICAgLnNjYWxlQmFuZCgpCiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHRoaXMud2lkdGhTVkddKQogICAgICAgICAgICAgICAgLnBhZGRpbmcoMC4xKTsKICAgICAgICAgICAgdGhpcy54MC5kb21haW4odGhpcy5rZXlzWDEpOwoKICAgICAgICAgICAgdGhpcy55ID0gZDMKICAgICAgICAgICAgICAgIC5zY2FsZUxpbmVhcigpCiAgICAgICAgICAgICAgICAuZG9tYWluKFswLCB0aGlzLm1heFgxXSkKICAgICAgICAgICAgICAgIC5uaWNlKCkKICAgICAgICAgICAgICAgIC5yYW5nZVJvdW5kKFt0aGlzLmhlaWdodFNWRywgMF0pOwoKICAgICAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBkMwogICAgICAgICAgICAgICAgLmxpbmUoKQogICAgICAgICAgICAgICAgLngoZnVuY3Rpb24oZCwgaSkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiB4MCh0aGlzLmtleXNYMFtpXSkgKyB4MC5iYW5kd2lkdGgoKSAvIDI7CiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgLnkoZnVuY3Rpb24oZCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiB5KGQpOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgfSwKICAgICAgICBkcmF3KCkgewogICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuc3ZnCiAgICAgICAgICAgICAgICAuYXBwZW5kKCJnIikKICAgICAgICAgICAgICAgIC5hdHRyKCJjbGFzcyIsICJzdmdjb250YWluZXIiKQogICAgICAgICAgICAgICAgLmF0dHIoImlkIiwgImNvbnRhaW5lcmlkIikKICAgICAgICAgICAgICAgIC5hdHRyKAogICAgICAgICAgICAgICAgICAgICJ0cmFuc2Zvcm0iLAogICAgICAgICAgICAgICAgICAgICJ0cmFuc2xhdGUoIiArCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFyZ2luLmxlZnQgKwogICAgICAgICAgICAgICAgICAgICAgICAiLCIgKwogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmdpbi50b3AgKwogICAgICAgICAgICAgICAgICAgICAgICAiKSIKICAgICAgICAgICAgICAgICk7CgogICAgICAgICAgICB0aGlzLnhBeGlzID0gdGhpcy5jb250YWluZXIKICAgICAgICAgICAgICAgIC5hcHBlbmQoImciKQogICAgICAgICAgICAgICAgLmF0dHIoImNsYXNzIiwgImF4aXMiKQogICAgICAgICAgICAgICAgLmF0dHIoImlkIiwgInhBeGlzIikKICAgICAgICAgICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKDAsIiArIHRoaXMuaGVpZ2h0U1ZHICsgIikiKQogICAgICAgICAgICAgICAgLmNhbGwoZDMuYXhpc0JvdHRvbSh0aGlzLngwKSk7CgogICAgICAgICAgICB0aGlzLnlBeGlzID0gdGhpcy5jb250YWluZXIKICAgICAgICAgICAgICAgIC5hcHBlbmQoImciKQogICAgICAgICAgICAgICAgLmF0dHIoImlkIiwgInlBeGlzIikKICAgICAgICAgICAgICAgIC5hdHRyKCJjbGFzcyIsICJheGlzIikKICAgICAgICAgICAgICAgIC5jYWxsKGQzLmF4aXNMZWZ0KHRoaXMueSkpCiAgICAgICAgICAgICAgICAuYXBwZW5kKCJ0ZXh0IikKICAgICAgICAgICAgICAgIC5hdHRyKCJ4IiwgMikKICAgICAgICAgICAgICAgIC5hdHRyKCJ5IiwgdGhpcy55KHRoaXMueS50aWNrcygpLnBvcCgpKSArIDAuNSkKICAgICAgICAgICAgICAgIC5hdHRyKCJkeSIsICIwLjMyZW0iKQogICAgICAgICAgICAgICAgLmF0dHIoImZpbGwiLCAiIzAwMCIpCiAgICAgICAgICAgICAgICAuYXR0cigiZm9udC13ZWlnaHQiLCAiYm9sZCIpCiAgICAgICAgICAgICAgICAuYXR0cigidGV4dC1hbmNob3IiLCAic3RhcnQiKQogICAgICAgICAgICAgICAgLnRleHQoImsiKTsKCiAgICAgICAgICAgIGxldCB4MCA9IHRoaXMueDA7CiAgICAgICAgICAgIGxldCB4MSA9IHRoaXMueDE7CiAgICAgICAgICAgIGxldCB2YWx1ZXMgPSB0aGlzLnZhbHVlczsKICAgICAgICAgICAgbGV0IHkgPSB0aGlzLnk7CiAgICAgICAgICAgIGxldCBrZXlzWDAgPSB0aGlzLmtleXNYMDsKICAgICAgICAgICAgbGV0IGtleXNYMSA9IHRoaXMua2V5c1gxOwogICAgICAgICAgICBsZXQgaGVpZ2h0U1ZHID0gdGhpcy5oZWlnaHRTVkc7CiAgICAgICAgICAgIGxldCB3aWR0aFNWRyA9IHRoaXMud2lkdGhTVkc7CiAgICAgICAgICAgIGxldCBtYXJnaW4gPSB0aGlzLm1hcmdpbjsKICAgICAgICAgICAgbGV0IGNvbG9yID0gdGhpcy5jb2xvcjsKCiAgICAgICAgICAgIGxldCBnZW5lcmF0b3IgPSBkMwogICAgICAgICAgICAgICAgLmxpbmUoKQogICAgICAgICAgICAgICAgLngoZnVuY3Rpb24oZCwgaSkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiB4MChrZXlzWDFbaV0pICsgeDAuYmFuZHdpZHRoKCkgLyAyOwogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIC55KGZ1bmN0aW9uKGQpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4geShkKTsKICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgdGhpcy5ncm91cHMgPSB0aGlzLmNvbnRhaW5lcgogICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgiLmxpbmUtZ3JvdXAiKQogICAgICAgICAgICAgICAgLmRhdGEoa2V5c1gxKQogICAgICAgICAgICAgICAgLmVudGVyKCkKICAgICAgICAgICAgICAgIC5hcHBlbmQoImciKQogICAgICAgICAgICAgICAgLmF0dHIoImZpbGwiLCBmdW5jdGlvbihkLCBpKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yKGkpOwogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIC5hdHRyKCJjbGFzcyIsIGZ1bmN0aW9uKGQpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gImxpbmUtZ3JvdXAgIiArIGQ7CiAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIHRoaXMubGluZXMgPSB0aGlzLmdyb3VwcwogICAgICAgICAgICAgICAgLmFwcGVuZCgicGF0aCIpCiAgICAgICAgICAgICAgICAuYXR0cigic3Ryb2tlIiwgZnVuY3Rpb24oZCwgaSkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcihpKTsKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAuZGF0dW0oZnVuY3Rpb24oZCkgewogICAgICAgICAgICAgICAgICAgIGxldCBkYXQgPSBbXTsKICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtleXNYMC5sZW5ndGg7IGsrKykgewogICAgICAgICAgICAgICAgICAgICAgICBkYXQucHVzaCh2YWx1ZXNba11bZF0pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0OwogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIC5hdHRyKCJjbGFzcyIsICJsaW5lIEdsb2JhbCIpCiAgICAgICAgICAgICAgICAuYXR0cigiZCIsIGdlbmVyYXRvcikKICAgICAgICAgICAgICAgIC5hdHRyKCJmaWxsIiwgIm5vbmUiKTsKCiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gdGhpcy5ncm91cHMKICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoIi5kb3QiKQogICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgewogICAgICAgICAgICAgICAgICAgIGxldCBkYXQgPSBbXTsKICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtleXNYMS5sZW5ndGg7IGsrKykgewogICAgICAgICAgICAgICAgICAgICAgICBkYXQucHVzaCh2YWx1ZXNba11bZF0pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0OwogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIC5lbnRlcigpCiAgICAgICAgICAgICAgICAuYXBwZW5kKCJjaXJjbGUiKSAvLyBVc2VzIHRoZSBlbnRlcigpLmFwcGVuZCgpIG1ldGhvZAogICAgICAgICAgICAgICAgLmF0dHIoImNsYXNzIiwgImRvdCIpIC8vIEFzc2lnbiBhIGNsYXNzIGZvciBzdHlsaW5nCiAgICAgICAgICAgICAgICAuYXR0cigiY3giLCBmdW5jdGlvbihkLCBpKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgwKGtleXNYMVtpXSkgKyB4MC5iYW5kd2lkdGgoKSAvIDI7CiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgLmF0dHIoImN5IiwgZnVuY3Rpb24oZCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiB5KGQpOwogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIC5hdHRyKCJyIiwgMyk7CiAgICAgICAgfSwKICAgICAgICB1cGRhdGUoKSB7fSwKICAgICAgICBjcmVhdGVYMUtleXModmFsdWVzKSB7CiAgICAgICAgICAgIGxldCBhcnIgPSBbXTsKCiAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdmFsdWUpIHsKICAgICAgICAgICAgICAgIGZvciAobGV0IGogaW4gdmFsdWVbaV0pIHsKICAgICAgICAgICAgICAgICAgICBpZiAoIWFyci5pbmNsdWRlcyhqKSkgewogICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChqKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGFycjsKICAgICAgICB9LAogICAgICAgIGZpbmRNYXgodmFsdWVzLCBrZXlzWDEpIHsKICAgICAgICAgICAgbGV0IG1heCA9IDA7CgogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzWDEubGVuZ3RoOyBqKyspIHsKICAgICAgICAgICAgICAgICAgICBsZXQgdG1wID0gdmFsdWVzW2ldOwoKICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdCh0bXBba2V5c1gxW2pdXSkgPiBwYXJzZUZsb2F0KG1heCkpCiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IHRtcFtrZXlzWDFbal1dOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICByZXR1cm4gbWF4OwogICAgICAgIH0KICAgIH0KfTsK"},{"version":3,"sources":["MultiLineChart.vue"],"names":[],"mappings":";;;;;;;;;AASA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"MultiLineChart.vue","sourceRoot":"src/components/diagrams","sourcesContent":["<template>\n    <div>\n        <h1>Multi Line Chart</h1>\n        <svg class=\"linechart\" :id=\"id\"></svg>\n        Noch buggy, warte bis wir den richtigen Datensatz haben\n    </div>\n</template>\n\n<script>\nimport * as d3 from \"d3\";\nimport { scaleLinear, scaleBand } from \"d3-scale\";\nimport { max, min } from \"d3-array\";\nimport { selectAll } from \"d3-selection\";\n\nexport default {\n    name: \"Test-Chart\",\n    props: {\n        data: Object\n    },\n    data() {\n        return {\n            testdata: {\n                PLA: {\n                    A: 1,\n                    B: 2\n                },\n                PBS: {\n                    A: 1,\n                    B: 4\n                }\n            },\n            id: 9000,\n            height: 600,\n            heightSVG: 0,\n            widthSVG: 0,\n            width: 600,\n            margin: { top: 30, right: 30, bottom: 30, left: 70 },\n            margin_top: 20,\n            margin_left: 50,\n            keysX0: [],\n            keysX1: [],\n            values: [],\n            maxX1: 0,\n            x0: Object,\n            x1: Object,\n            y: Object,\n            color: Object,\n            svg: Object,\n            container: Object,\n            xAxis: Object,\n            yAxis: Object,\n            groups: Object,\n            lines: Object,\n            points: Object\n        };\n    },\n    computed: {},\n    mounted() {\n        this.init();\n        this.draw();\n    },\n    created() {\n    },\n    methods: {\n        init() {\n            this.svg = d3.select(document.getElementById(this.id));\n            this.svg\n                .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n                .attr(\"viewBox\", \"0 0 \" + this.width + \" \" + this.height);\n\n            this.widthSVG = this.width - this.margin.left - this.margin.right;\n            this.heightSVG = this.height - this.margin.top - this.margin.bottom;\n\n            this.keysX0 = Object.keys(this.testdata);\n            this.values = Object.values(this.testdata);\n            this.keysX1 = Object.keys(this.values[0]);\n\n            this.color = d3.scaleOrdinal(d3.schemeCategory10);\n\n            this.maxX1 = this.findMax(this.values, this.keysX1);\n\n            this.x0 = d3\n                .scaleBand()\n                .range([0, this.widthSVG])\n                .padding(0.1);\n            this.x0.domain(this.keysX1);\n\n            this.y = d3\n                .scaleLinear()\n                .domain([0, this.maxX1])\n                .nice()\n                .rangeRound([this.heightSVG, 0]);\n\n            this.generator = d3\n                .line()\n                .x(function(d, i) {\n                    return x0(this.keysX0[i]) + x0.bandwidth() / 2;\n                })\n                .y(function(d) {\n                    return y(d);\n                });\n        },\n        draw() {\n            this.container = this.svg\n                .append(\"g\")\n                .attr(\"class\", \"svgcontainer\")\n                .attr(\"id\", \"containerid\")\n                .attr(\n                    \"transform\",\n                    \"translate(\" +\n                        this.margin.left +\n                        \",\" +\n                        this.margin.top +\n                        \")\"\n                );\n\n            this.xAxis = this.container\n                .append(\"g\")\n                .attr(\"class\", \"axis\")\n                .attr(\"id\", \"xAxis\")\n                .attr(\"transform\", \"translate(0,\" + this.heightSVG + \")\")\n                .call(d3.axisBottom(this.x0));\n\n            this.yAxis = this.container\n                .append(\"g\")\n                .attr(\"id\", \"yAxis\")\n                .attr(\"class\", \"axis\")\n                .call(d3.axisLeft(this.y))\n                .append(\"text\")\n                .attr(\"x\", 2)\n                .attr(\"y\", this.y(this.y.ticks().pop()) + 0.5)\n                .attr(\"dy\", \"0.32em\")\n                .attr(\"fill\", \"#000\")\n                .attr(\"font-weight\", \"bold\")\n                .attr(\"text-anchor\", \"start\")\n                .text(\"k\");\n\n            let x0 = this.x0;\n            let x1 = this.x1;\n            let values = this.values;\n            let y = this.y;\n            let keysX0 = this.keysX0;\n            let keysX1 = this.keysX1;\n            let heightSVG = this.heightSVG;\n            let widthSVG = this.widthSVG;\n            let margin = this.margin;\n            let color = this.color;\n\n            let generator = d3\n                .line()\n                .x(function(d, i) {\n                    return x0(keysX1[i]) + x0.bandwidth() / 2;\n                })\n                .y(function(d) {\n                    return y(d);\n                });\n\n            this.groups = this.container\n                .selectAll(\".line-group\")\n                .data(keysX1)\n                .enter()\n                .append(\"g\")\n                .attr(\"fill\", function(d, i) {\n                    return color(i);\n                })\n                .attr(\"class\", function(d) {\n                    return \"line-group \" + d;\n                });\n\n            this.lines = this.groups\n                .append(\"path\")\n                .attr(\"stroke\", function(d, i) {\n                    return color(i);\n                })\n                .datum(function(d) {\n                    let dat = [];\n                    for (let k = 0; k < keysX0.length; k++) {\n                        dat.push(values[k][d]);\n                    }\n                    return dat;\n                })\n                .attr(\"class\", \"line Global\")\n                .attr(\"d\", generator)\n                .attr(\"fill\", \"none\");\n\n            this.points = this.groups\n                .selectAll(\".dot\")\n                .data(function(d) {\n                    let dat = [];\n                    for (let k = 0; k < keysX1.length; k++) {\n                        dat.push(values[k][d]);\n                    }\n                    return dat;\n                })\n                .enter()\n                .append(\"circle\") // Uses the enter().append() method\n                .attr(\"class\", \"dot\") // Assign a class for styling\n                .attr(\"cx\", function(d, i) {\n                    return x0(keysX1[i]) + x0.bandwidth() / 2;\n                })\n                .attr(\"cy\", function(d) {\n                    return y(d);\n                })\n                .attr(\"r\", 3);\n        },\n        update() {},\n        createX1Keys(values) {\n            let arr = [];\n\n            for (let i in value) {\n                for (let j in value[i]) {\n                    if (!arr.includes(j)) {\n                        arr.push(j);\n                    }\n                }\n            }\n            return arr;\n        },\n        findMax(values, keysX1) {\n            let max = 0;\n\n            for (let i = 0; i < values.length; i++) {\n                for (let j = 0; j < keysX1.length; j++) {\n                    let tmp = values[i];\n\n                    if (parseFloat(tmp[keysX1[j]]) > parseFloat(max))\n                        max = tmp[keysX1[j]];\n                }\n            }\n\n            return max;\n        }\n    }\n};\n</script>\n\n<style scoped></style>\n"]}]}