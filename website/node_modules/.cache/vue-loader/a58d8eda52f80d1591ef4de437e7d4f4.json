{"remainingRequest":"C:\\Studium\\Angewandte_Informatik\\Master\\2te_Semester\\Seminar\\datamining_frequent_itemset\\datamining_frequent_itemset\\website\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Studium\\Angewandte_Informatik\\Master\\2te_Semester\\Seminar\\datamining_frequent_itemset\\datamining_frequent_itemset\\website\\src\\components\\diagrams\\MultiLineChart.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Studium\\Angewandte_Informatik\\Master\\2te_Semester\\Seminar\\datamining_frequent_itemset\\datamining_frequent_itemset\\website\\src\\components\\diagrams\\MultiLineChart.vue","mtime":1586802062000},{"path":"C:\\Studium\\Angewandte_Informatik\\Master\\2te_Semester\\Seminar\\datamining_frequent_itemset\\datamining_frequent_itemset\\website\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Studium\\Angewandte_Informatik\\Master\\2te_Semester\\Seminar\\datamining_frequent_itemset\\datamining_frequent_itemset\\website\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\Studium\\Angewandte_Informatik\\Master\\2te_Semester\\Seminar\\datamining_frequent_itemset\\datamining_frequent_itemset\\website\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Studium\\Angewandte_Informatik\\Master\\2te_Semester\\Seminar\\datamining_frequent_itemset\\datamining_frequent_itemset\\website\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJwppbXBvcnQgeyBzY2FsZUxpbmVhciwgc2NhbGVCYW5kIH0gZnJvbSAiZDMtc2NhbGUiOwppbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gImQzLWFycmF5IjsKaW1wb3J0IHsgc2VsZWN0QWxsIH0gZnJvbSAiZDMtc2VsZWN0aW9uIjsKCmV4cG9ydCBkZWZhdWx0IHsKICAgIG5hbWU6ICJUZXN0LUNoYXJ0IiwKICAgIHByb3BzOiB7CiAgICAgICAgZGF0YSA6IE9iamVjdCwKICAgIH0sCiAgICBkYXRhKCkgewogICAgICAgIHJldHVybnsKICAgICAgICAgICAgdGVzdGRhdGE6ewogICAgICAgICAgICAgICAgIlBMQSI6IHsKICAgICAgICAgICAgICAgICAgICAiQSI6MSwKICAgICAgICAgICAgICAgICAgICAiQiI6MiwKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAiUEJTIjogewogICAgICAgICAgICAgICAgICAgICJBIjoxLAogICAgICAgICAgICAgICAgICAgICJCIjo0LAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBpZDogOTAwMCwKICAgICAgICAgICAgaGVpZ2h0OiA2MDAsCiAgICAgICAgICAgIGhlaWdodFNWRzogMCwKICAgICAgICAgICAgd2lkdGhTVkc6IDAsCiAgICAgICAgICAgIHdpZHRoOiA2MDAsCiAgICAgICAgICAgIG1hcmdpbjoge3RvcDogMzAsIHJpZ2h0OiAzMCwgYm90dG9tOiAzMCwgbGVmdDogNzB9LAogICAgICAgICAgICBtYXJnaW5fdG9wIDogMjAsCiAgICAgICAgICAgIG1hcmdpbl9sZWZ0OiA1MCwKICAgICAgICAgICAga2V5c1gwIDogW10sCiAgICAgICAgICAgIGtleXNYMSA6IFtdLAogICAgICAgICAgICB2YWx1ZXM6IFtdLAogICAgICAgICAgICBtYXhYMSA6IDAsCiAgICAgICAgICAgIHgwOiBPYmplY3QsCiAgICAgICAgICAgIHgxOiBPYmplY3QsCiAgICAgICAgICAgIHk6IE9iamVjdCwKICAgICAgICAgICAgY29sb3I6IE9iamVjdCwKICAgICAgICAgICAgc3ZnOiBPYmplY3QsCiAgICAgICAgICAgIGNvbnRhaW5lcjogT2JqZWN0LAogICAgICAgICAgICB4QXhpczogT2JqZWN0LAogICAgICAgICAgICB5QXhpczogT2JqZWN0LAogICAgICAgICAgICBncm91cHM6IE9iamVjdCwKICAgICAgICAgICAgbGluZXM6IE9iamVjdCwKICAgICAgICAgICAgcG9pbnRzOiBPYmplY3QKICAgICAgICB9CiAgICB9LAogICAgY29tcHV0ZWQ6IHsKICAgIH0sCiAgICBtb3VudGVkKCl7CiAgICAgICAgdGhpcy5pbml0KCk7CiAgICAgICAgdGhpcy5kcmF3KCk7CiAgICB9LAogICAgY3JlYXRlZCgpewogICAgICAgIGNvbnNvbGUubG9nKCJsaW5lIGNoYXJ0IGNyZWF0ZWQiKQogICAgfSwKICAgIG1ldGhvZHM6IHsKICAgICAgICBpbml0KCl7CiAgICAgICAgICAgIHRoaXMuc3ZnID0gZDMuc2VsZWN0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpKTsKICAgICAgICAgICAgdGhpcy5zdmcuYXR0cigicHJlc2VydmVBc3BlY3RSYXRpbyIsICJ4TWluWU1pbiBtZWV0IikKICAgICAgICAgICAgICAgICAgICAuYXR0cigidmlld0JveCIsICIwIDAgIiArIHRoaXMud2lkdGggKyAiICIgKyB0aGlzLmhlaWdodCk7CgogICAgICAgICAgICB0aGlzLndpZHRoU1ZHID0gdGhpcy53aWR0aCAtIHRoaXMubWFyZ2luLmxlZnQgLSB0aGlzLm1hcmdpbi5yaWdodDsKICAgICAgICAgICAgdGhpcy5oZWlnaHRTVkcgPSB0aGlzLmhlaWdodCAtIHRoaXMubWFyZ2luLnRvcCAtIHRoaXMubWFyZ2luLmJvdHRvbTsKCiAgICAgICAgICAgIHRoaXMua2V5c1gwID0gT2JqZWN0LmtleXModGhpcy50ZXN0ZGF0YSk7CiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gT2JqZWN0LnZhbHVlcyh0aGlzLnRlc3RkYXRhKTsKICAgICAgICAgICAgdGhpcy5rZXlzWDEgPSBPYmplY3Qua2V5cyh0aGlzLnZhbHVlc1swXSk7CgogICAgICAgICAgICB0aGlzLmNvbG9yID0gZDMuc2NhbGVPcmRpbmFsKGQzLnNjaGVtZUNhdGVnb3J5MTApOwoKICAgICAgICAgICAgdGhpcy5tYXhYMSA9IHRoaXMuZmluZE1heCh0aGlzLnZhbHVlcywgdGhpcy5rZXlzWDEpOwoKICAgICAgICAgICAgdGhpcy54MCA9IGQzLnNjYWxlQmFuZCgpLnJhbmdlKFswLCB0aGlzLndpZHRoU1ZHXSkucGFkZGluZygwLjEpOwogICAgICAgICAgICB0aGlzLngwLmRvbWFpbih0aGlzLmtleXNYMSk7CgoKICAgICAgICAgICAgdGhpcy55ID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIHRoaXMubWF4WDFdKS5uaWNlKCkucmFuZ2VSb3VuZChbdGhpcy5oZWlnaHRTVkcsIDBdKTsKCiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gICBkMy5saW5lKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLngoZnVuY3Rpb24gKGQsIGkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4MCh0aGlzLmtleXNYMFtpXSkgKyB4MC5iYW5kd2lkdGgoKSAvIDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC55KGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geShkKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgfSwKICAgICAgICBkcmF3KCl7CiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5zdmcuYXBwZW5kKCJnIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigiY2xhc3MiLCAic3ZnY29udGFpbmVyIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigiaWQiLCAiY29udGFpbmVyaWQiKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKCIgKyB0aGlzLm1hcmdpbi5sZWZ0ICsgIiwiICsgdGhpcy5tYXJnaW4udG9wICsgIikiKTsKCiAgICAgICAgICAgIHRoaXMueEF4aXMgPSB0aGlzLmNvbnRhaW5lci5hcHBlbmQoImciKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigiY2xhc3MiLCAiYXhpcyIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCJpZCIsICJ4QXhpcyIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKDAsIiArIHRoaXMuaGVpZ2h0U1ZHICsgIikiKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2FsbChkMy5heGlzQm90dG9tKHRoaXMueDApKTsKCiAgICAgICAgICAgIHRoaXMueUF4aXMgPSB0aGlzLmNvbnRhaW5lci5hcHBlbmQoImciKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoImlkIiwgInlBeGlzIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCJjbGFzcyIsICJheGlzIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsKGQzLmF4aXNMZWZ0KHRoaXMueSkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCJ0ZXh0IikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCJ4IiwgMikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCJ5IiwgdGhpcy55KHRoaXMueS50aWNrcygpLnBvcCgpKSArIDAuNSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCJkeSIsICIwLjMyZW0iKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoImZpbGwiLCAiIzAwMCIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigiZm9udC13ZWlnaHQiLCAiYm9sZCIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigidGV4dC1hbmNob3IiLCAic3RhcnQiKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoImsiKTsKCiAgICAgICAgICAgIGxldCB4MCA9IHRoaXMueDA7CiAgICAgICAgICAgIGxldCB4MSA9IHRoaXMueDE7CiAgICAgICAgICAgIGxldCB2YWx1ZXMgPSB0aGlzLnZhbHVlczsKICAgICAgICAgICAgbGV0IHkgPSB0aGlzLnk7CiAgICAgICAgICAgIGxldCBrZXlzWDAgPSB0aGlzLmtleXNYMDsKICAgICAgICAgICAgbGV0IGtleXNYMSA9IHRoaXMua2V5c1gxOwogICAgICAgICAgICBsZXQgaGVpZ2h0U1ZHID0gdGhpcy5oZWlnaHRTVkc7CiAgICAgICAgICAgIGxldCB3aWR0aFNWRyA9IHRoaXMud2lkdGhTVkc7CiAgICAgICAgICAgIGxldCBtYXJnaW4gPSB0aGlzLm1hcmdpbjsKICAgICAgICAgICAgbGV0IGNvbG9yID0gdGhpcy5jb2xvcjsKCiAgICAgICAgICAgIGxldCBnZW5lcmF0b3IgPSAgIGQzLmxpbmUoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAueChmdW5jdGlvbiAoZCwgaSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgwKGtleXNYMVtpXSkgKyB4MC5iYW5kd2lkdGgoKSAvIDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC55KGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geShkKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICB0aGlzLmdyb3VwcyA9IHRoaXMuY29udGFpbmVyLnNlbGVjdEFsbCgiLmxpbmUtZ3JvdXAiKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKGtleXNYMSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoImciKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCJmaWxsIiwgZnVuY3Rpb24gKGQsIGkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yKGkpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoImNsYXNzIiwgZnVuY3Rpb24gKGQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICJsaW5lLWdyb3VwICIgKyBkOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgIHRoaXMubGluZXMgPSB0aGlzLmdyb3Vwcy5hcHBlbmQoInBhdGgiKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoInN0cm9rZSIsIGZ1bmN0aW9uIChkLCBpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yKGkpOyAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZnVuY3Rpb24gKGQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0ID0gW107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBrZXlzWDAubGVuZ3RoOyBrKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0LnB1c2godmFsdWVzW2tdW2RdKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigiY2xhc3MiLCAibGluZSBHbG9iYWwiKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoImQiLCBnZW5lcmF0b3IpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigiZmlsbCIsICJub25lIik7CgogICAgICAgICAgICB0aGlzLnBvaW50cyA9IHRoaXMuZ3JvdXBzLnNlbGVjdEFsbCgiLmRvdCIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0ID0gW107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtleXNYMS5sZW5ndGg7IGsrKykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdC5wdXNoKHZhbHVlc1trXVtkXSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5lbnRlcigpLmFwcGVuZCgiY2lyY2xlIikvLyBVc2VzIHRoZSBlbnRlcigpLmFwcGVuZCgpIG1ldGhvZAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigiY2xhc3MiLCAiZG90IikgLy8gQXNzaWduIGEgY2xhc3MgZm9yIHN0eWxpbmcKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoImN4IiwgZnVuY3Rpb24gKGQsIGkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4MChrZXlzWDFbaV0pICsgeDAuYmFuZHdpZHRoKCkgLyAyCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCJjeSIsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geShkKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigiciIsIDMpOwogICAgICAgIH0sCiAgICAgICAgdXBkYXRlKCl7CgogICAgICAgIH0sCiAgICAgICAgY3JlYXRlWDFLZXlzKHZhbHVlcyl7CiAgICAgICAgICAgIGxldCBhcnIgPSBbXTsKCiAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdmFsdWUpIHsKICAgICAgICAgICAgICAgIGZvciAobGV0IGogaW4gdmFsdWVbaV0pIHsKICAgICAgICAgICAgICAgICAgICBpZiAoIWFyci5pbmNsdWRlcyhqKSkgewogICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChqKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGFycjsKICAgICAgICB9LAogICAgICAgIGZpbmRNYXgodmFsdWVzLCBrZXlzWDEpewogICAgICAgICAgICBsZXQgbWF4ID0gMDsKCiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspewogICAgICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IGtleXNYMS5sZW5ndGg7IGorKyl7CiAgICAgICAgICAgICAgICAgICAgbGV0IHRtcCA9IHZhbHVlc1tpXTsKCiAgICAgICAgICAgICAgICAgICAgaWYocGFyc2VGbG9hdCh0bXBba2V5c1gxW2pdXSkgPiBwYXJzZUZsb2F0KG1heCkgKQogICAgICAgICAgICAgICAgICAgICAgICBtYXggPSB0bXBba2V5c1gxW2pdXTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgcmV0dXJuIG1heDsKICAgICAgICB9CiAgICB9Cn0K"},{"version":3,"sources":["MultiLineChart.vue"],"names":[],"mappings":";;;;;;;;;;AAUA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"MultiLineChart.vue","sourceRoot":"src/components/diagrams","sourcesContent":["<template>\n    <div>\n        <h1>Multi Line Chart</h1>\n        <svg class=\"linechart\"  :id=\"id\">\n        </svg>\n        Noch buggy, warte bis wir den richtigen Datensatz haben\n    </div>\n</template>\n\n<script>\nimport * as d3 from 'd3'\nimport { scaleLinear, scaleBand } from \"d3-scale\";\nimport { max, min } from \"d3-array\";\nimport { selectAll } from \"d3-selection\";\n\nexport default {\n    name: \"Test-Chart\",\n    props: {\n        data : Object,\n    },\n    data() {\n        return{\n            testdata:{\n                \"PLA\": {\n                    \"A\":1,\n                    \"B\":2,\n                },\n                \"PBS\": {\n                    \"A\":1,\n                    \"B\":4,\n                }\n            },\n            id: 9000,\n            height: 600,\n            heightSVG: 0,\n            widthSVG: 0,\n            width: 600,\n            margin: {top: 30, right: 30, bottom: 30, left: 70},\n            margin_top : 20,\n            margin_left: 50,\n            keysX0 : [],\n            keysX1 : [],\n            values: [],\n            maxX1 : 0,\n            x0: Object,\n            x1: Object,\n            y: Object,\n            color: Object,\n            svg: Object,\n            container: Object,\n            xAxis: Object,\n            yAxis: Object,\n            groups: Object,\n            lines: Object,\n            points: Object\n        }\n    },\n    computed: {\n    },\n    mounted(){\n        this.init();\n        this.draw();\n    },\n    created(){\n        console.log(\"line chart created\")\n    },\n    methods: {\n        init(){\n            this.svg = d3.select(document.getElementById(this.id));\n            this.svg.attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n                    .attr(\"viewBox\", \"0 0 \" + this.width + \" \" + this.height);\n\n            this.widthSVG = this.width - this.margin.left - this.margin.right;\n            this.heightSVG = this.height - this.margin.top - this.margin.bottom;\n\n            this.keysX0 = Object.keys(this.testdata);\n            this.values = Object.values(this.testdata);\n            this.keysX1 = Object.keys(this.values[0]);\n\n            this.color = d3.scaleOrdinal(d3.schemeCategory10);\n\n            this.maxX1 = this.findMax(this.values, this.keysX1);\n\n            this.x0 = d3.scaleBand().range([0, this.widthSVG]).padding(0.1);\n            this.x0.domain(this.keysX1);\n\n\n            this.y = d3.scaleLinear().domain([0, this.maxX1]).nice().rangeRound([this.heightSVG, 0]);\n\n            this.generator =   d3.line()\n                                    .x(function (d, i) {\n                                        return x0(this.keysX0[i]) + x0.bandwidth() / 2;\n                                    })\n                                    .y(function (d) {\n                                        return y(d);\n                                    });\n        },\n        draw(){\n            this.container = this.svg.append(\"g\")\n                                .attr(\"class\", \"svgcontainer\")\n                                .attr(\"id\", \"containerid\")\n                                .attr(\"transform\", \"translate(\" + this.margin.left + \",\" + this.margin.top + \")\");\n\n            this.xAxis = this.container.append(\"g\")\n                                    .attr(\"class\", \"axis\")\n                                    .attr(\"id\", \"xAxis\")\n                                    .attr(\"transform\", \"translate(0,\" + this.heightSVG + \")\")\n                                    .call(d3.axisBottom(this.x0));\n\n            this.yAxis = this.container.append(\"g\")\n                                        .attr(\"id\", \"yAxis\")\n                                        .attr(\"class\", \"axis\")\n                                        .call(d3.axisLeft(this.y))\n                                        .append(\"text\")\n                                        .attr(\"x\", 2)\n                                        .attr(\"y\", this.y(this.y.ticks().pop()) + 0.5)\n                                        .attr(\"dy\", \"0.32em\")\n                                        .attr(\"fill\", \"#000\")\n                                        .attr(\"font-weight\", \"bold\")\n                                        .attr(\"text-anchor\", \"start\")\n                                        .text(\"k\");\n\n            let x0 = this.x0;\n            let x1 = this.x1;\n            let values = this.values;\n            let y = this.y;\n            let keysX0 = this.keysX0;\n            let keysX1 = this.keysX1;\n            let heightSVG = this.heightSVG;\n            let widthSVG = this.widthSVG;\n            let margin = this.margin;\n            let color = this.color;\n\n            let generator =   d3.line()\n                                    .x(function (d, i) {\n                                        return x0(keysX1[i]) + x0.bandwidth() / 2;\n                                    })\n                                    .y(function (d) {\n                                        return y(d);\n                                    });\n\n            this.groups = this.container.selectAll(\".line-group\")\n                                .data(keysX1)\n                                .enter()\n                                .append(\"g\")\n                                .attr(\"fill\", function (d, i) {\n                                    return color(i);\n                                })\n                                .attr(\"class\", function (d) {\n                                    return \"line-group \" + d;\n                                });        \n                                \n            this.lines = this.groups.append(\"path\")\n                            .attr(\"stroke\", function (d, i) {\n                                return color(i);    \n                            })\n                            .datum(function (d) {\n                                let dat = [];\n                                for (let k = 0; k < keysX0.length; k++) {\n                                    dat.push(values[k][d]);\n                                }\n                                return dat;\n                            })\n                            .attr(\"class\", \"line Global\")\n                            .attr(\"d\", generator)\n                            .attr(\"fill\", \"none\");\n\n            this.points = this.groups.selectAll(\".dot\")\n                                    .data(function (d) {\n                                        let dat = [];\n                                        for (let k = 0; k < keysX1.length; k++) {\n                                            dat.push(values[k][d]);\n                                        }\n                                        return dat;\n                                    }).enter().append(\"circle\")// Uses the enter().append() method\n                                    .attr(\"class\", \"dot\") // Assign a class for styling\n                                    .attr(\"cx\", function (d, i) {\n                                        return x0(keysX1[i]) + x0.bandwidth() / 2\n                                    })\n                                    .attr(\"cy\", function (d) {\n                                        return y(d)\n                                    })\n                                    .attr(\"r\", 3);\n        },\n        update(){\n\n        },\n        createX1Keys(values){\n            let arr = [];\n\n            for (let i in value) {\n                for (let j in value[i]) {\n                    if (!arr.includes(j)) {\n                        arr.push(j);\n                    }\n                }\n            }\n            return arr;\n        },\n        findMax(values, keysX1){\n            let max = 0;\n\n            for(let i = 0; i < values.length; i++){\n                for(let j = 0; j < keysX1.length; j++){\n                    let tmp = values[i];\n\n                    if(parseFloat(tmp[keysX1[j]]) > parseFloat(max) )\n                        max = tmp[keysX1[j]];\n                }\n            }\n\n            return max;\n        }\n    }\n}\n</script>\n\n<style scoped>\n</style>"]}]}